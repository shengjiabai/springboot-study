1.你是否了解 MVCC？
答：MVCC 是 MySQL InnoDB 引擎用于控制数据并发访问的协议。MVCC 主要是借助于版本链来实现的。在 InnoDB 引擎里面，每一行都有两个额外的列，一个是 trx_id，代表的是修改这一行数据的事务 ID。另外一个是 roll_ptr，代表的是回滚指针。InnoDB 引擎通过回滚指针，将数据的不同版本串联在一起，也就是版本链。这些串联起来的历史版本，被放到了 undolog 里面。当某一个事务发起查询的时候，MVCC 会根据事务的隔离级别来生成不同的 ReadView，从而控制事务查询最终得到的结果
2.没有 redo log 会怎样?
 没有 redo log 的话，写到 buffer pool，宕机了就会丢失数据为什么非得引入 redolog，干嘛不直接修改数据? 直接修改数据就是随机写，性能极差
3.索引？
答： 建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的 数据，则从磁盘中读入的数据也就越少。
Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）7.4 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代思路：先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。我的答案：Java堆= 老年代+ 新生代新生代= Eden + S0 + S1当Eden 区的空间满了， Java虚拟机会触发一次Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
4.mysql  cast  as 语法 CAST函数用于将值从一种数据类型转换为表达式中指定的另一种数据类型
    cast(c.amount_collected / 100 as decimal(16,2)) as amountCollected,